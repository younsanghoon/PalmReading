# SPA 라우팅 문제 해결 및 경로 정규화 분석

## 개요

PalmReading 애플리케이션은 React 기반의 SPA(Single Page Application)로, 클라이언트 측 라우팅을 위해 wouter 라이브러리를 사용합니다. 이 문서는 테스트 페이지 간 라우팅이 작동하지 않는 문제의 원인과 해결 방법, 그리고 SPA에서 효과적인 경로 정규화 전략에 대해 분석합니다.

## 문제 상황

메인 페이지에서 테스트 카드를 클릭했을 때 다음과 같은 문제가 발생했습니다:

1. 클릭 이벤트는 정상적으로 발생하지만 페이지 전환이 이루어지지 않음
2. 서버 로그에서 `/PalmReading/` 경로로 요청이 발생하는 것을 확인
3. 브라우저 콘솔에서 라우팅 관련 오류 메시지 없음

이러한 문제의 근본 원인은 다음과 같습니다:

1. **경로 정규화 부재**: 일부 경로에서 선행 슬래시(`/`)가 누락됨
2. **개발/배포 환경 차이**: 개발 환경과 배포 환경(GitHub Pages)에서 경로 처리 방식의 불일치
3. **중복 네비게이션 처리 부재**: 같은 경로로의 중복 네비게이션 시도 시 처리 로직 부재

## 문제 해결 과정

### 1. 경로 정규화 문제 식별

로깅을 통해 다음과 같은 경로 처리 문제를 확인했습니다:

```
[Router] Navigating to: animal-test
[Router] Actual path: animal-test
```

경로가 슬래시(`/`)로 시작하지 않아 상대 경로로 처리되는 문제가 발생했습니다. 올바른 경로는 `/animal-test`여야 합니다.

### 2. useBasePath 훅 분석

`App.tsx`의 `useBasePath` 훅은 다음과 같은 역할을 합니다:

1. 현재 환경(개발/배포)에 따라 기본 경로(base path) 결정
2. 현재 URL에서 기본 경로를 제거하여 내부 라우팅에 사용할 정규화된 경로 생성
3. 내부 경로에 기본 경로를 추가하여 실제 브라우저 URL 생성

문제는 내부 경로가 항상 슬래시로 시작한다고 가정하고 있지만, 실제로는 그렇지 않은 경우가 있었습니다.

### 3. 해결 방안 구현

#### 경로 정규화 로직 추가

모든 내부 경로가 슬래시로 시작하도록 정규화 로직을 추가했습니다:

```typescript
// 경로가 이미 슬래시로 시작하는지 확인
const normalizedTo = to.startsWith('/') ? to : `/${to}`;
console.log("[Router] Normalized destination:", normalizedTo);

// 개발 환경에서는 base path를 추가하지 않음
const newPath = isDev 
  ? normalizedTo 
  : (normalizedTo === "/" ? basePath : `${basePath}${normalizedTo}`);
```

#### 중복 네비게이션 방지 로직 추가

같은 경로로의 중복 네비게이션을 방지하는 로직을 추가했습니다:

```typescript
// 현재 경로와 새 경로가 같은지 확인
if (loc === newPath) {
  console.log("[Router] Already at this location, not navigating");
  return;
}
```

#### 컴포넌트 레벨 경로 정규화

`home.tsx`의 `handleTestClick` 함수에도 경로 정규화 로직을 추가했습니다:

```typescript
// 경로가 슬래시로 시작하는지 확인하고, 시작하지 않으면 슬래시 추가
const normalizedHref = href.startsWith('/') ? href : `/${href}`;
console.log("[Home] Normalized href:", normalizedHref);
```

## SPA 라우팅 모범 사례

이 프로젝트의 경험을 바탕으로 SPA에서 효과적인 라우팅 관리를 위한 모범 사례를 다음과 같이 정리할 수 있습니다:

### 1. 일관된 경로 형식 유지

- **절대 경로 사용**: 모든 내부 라우팅에 절대 경로(슬래시로 시작하는 경로) 사용
- **경로 정규화**: 모든 경로가 일관된 형식을 따르도록 정규화 함수 사용
- **중앙화된 경로 관리**: 애플리케이션 전체에서 사용되는 경로를 중앙에서 관리

```typescript
// 경로 정규화 유틸리티 함수 예시
export function normalizePath(path: string): string {
  // 슬래시로 시작하지 않으면 추가
  if (!path.startsWith('/')) {
    path = `/${path}`;
  }
  
  // 끝에 슬래시가 있으면 제거 (선택적)
  if (path.length > 1 && path.endsWith('/')) {
    path = path.slice(0, -1);
  }
  
  return path;
}
```

### 2. 환경별 기본 경로 관리

- **환경 감지**: 개발/배포 환경에 따라 다른 기본 경로 사용
- **설정 중앙화**: 환경별 설정을 중앙에서 관리하여 일관성 유지
- **동적 기본 경로**: 런타임에 환경에 따라 기본 경로 결정

```typescript
// 환경별 기본 경로 설정 예시
export function getBasePath(): string {
  // 개발 환경에서는 빈 문자열 사용
  if (process.env.NODE_ENV === 'development') {
    return '';
  }
  
  // 배포 환경에서는 프로젝트 이름 사용 (GitHub Pages 등)
  return '/PalmReading';
}
```

### 3. 라우팅 디버깅 강화

- **상세 로깅**: 라우팅 과정의 각 단계별 로그 추가
- **경로 변환 추적**: 원본 경로와 변환된 경로 모두 로깅
- **오류 처리**: 라우팅 과정에서 발생할 수 있는 오류 캐치 및 로깅

```typescript
// 라우팅 로깅 예시
function navigate(to: string) {
  console.log(`[Router] Original destination: ${to}`);
  
  const normalizedPath = normalizePath(to);
  console.log(`[Router] Normalized path: ${normalizedPath}`);
  
  const fullPath = `${getBasePath()}${normalizedPath}`;
  console.log(`[Router] Full path: ${fullPath}`);
  
  // 실제 네비게이션 수행
  window.history.pushState(null, "", fullPath);
}
```

### 4. 중복 네비게이션 및 에지 케이스 처리

- **중복 네비게이션 방지**: 같은 경로로의 중복 네비게이션 감지 및 방지
- **에지 케이스 처리**: 빈 경로, 해시 프래그먼트, 쿼리 파라미터 등의 특수 케이스 처리
- **오류 복구**: 라우팅 실패 시 폴백 메커니즘 제공

```typescript
// 중복 네비게이션 방지 예시
function navigate(to: string) {
  const currentPath = window.location.pathname;
  const targetPath = `${getBasePath()}${normalizePath(to)}`;
  
  if (currentPath === targetPath) {
    console.log(`[Router] Already at ${targetPath}, skipping navigation`);
    return;
  }
  
  // 실제 네비게이션 수행
  window.history.pushState(null, "", targetPath);
}
```

## 결론

SPA에서 효과적인 라우팅 관리는 일관된 사용자 경험을 제공하고 개발자 경험을 향상시키는 데 중요합니다. 이 프로젝트에서는 다음과 같은 접근 방식으로 라우팅 문제를 해결했습니다:

1. 모든 경로가 일관된 형식(슬래시로 시작하는 절대 경로)을 따르도록 정규화
2. 개발 환경과 배포 환경 간의 경로 처리 차이를 명확히 구분
3. 중복 네비게이션 및 에지 케이스에 대한 처리 로직 추가
4. 상세 로깅을 통한 라우팅 과정 추적 및 디버깅 용이성 확보

이러한 접근 방식은 React 기반 SPA의 클라이언트 측 라우팅 문제를 해결하는 데 효과적인 패턴을 제공합니다. 